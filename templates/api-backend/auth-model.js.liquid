{% render "../../templates/license_header_js.liquid",
		project     : project.attributes.backend_project_name,
  		description : project.attributes.backend_project_description,
		authors     : project.attributes.authors,
		copyright   : project.attributes.copyright,
		filename    : 'auth-model.js'
		%}
'use strict';
const assert = require('assert');
const jwt = require('jsonwebtoken');

class AuthModel {

	static #model = null;
	static #config = null;
	static #secret = null;

	static initialize = (config) => {
		assert(this.#model === null);
		assert(config !== undefined);
		this.#config = config;
		this.#secret = config.security.tokenSecret;
		assert(this.#secret !== undefined);

		const ModelSingleton = require('./model.js');
		this.#model = ModelSingleton.getInstance();
	}

	//TODO  replace email, password and user with project.attributes
	static async register(email, password) {
		assert(this.#model !== null);
		const db = this.#model.db;
		let sql = 'SELECT email FROM users WHERE email = ?';
		let result = await db.query(sql, [ email ]);
		if (result.code)
			throw new Error(result.code);
		if (result.length > 0) 
			throw new Error('An account with this email already exists');
		const saltRounds = 10; // TODO hard coded value
		const bcrypt = require('bcrypt');
		const passwordHash = await bcrypt.hash(password, saltRounds)
		const sqlRequest = `INSERT INTO users(email, password) VALUES (?, ?);`;
		console.log("dOm sql:" + sqlRequest);
		const sqlParams = [
			email,
			passwordHash
		];
		result = await db.query(sqlRequest, sqlParams);
		if (result.code)
			throw new Error(result.code);
		const userId = result.insertId;
		return userId;
	}

	static async login(email, password) {
		assert(this.#model !== null);
		const db = this.#model.db;
		let sql = 'SELECT id, email, password, account_locked FROM users WHERE email = ?';
		const result = await db.query(sql, [ email ]);
		if (result.code)
			throw new Error(result.code);
		if (result.length === 0) 
			throw new Error('Unknown email or invalid password');
		const bcrypt = require('bcrypt');
		const passwordValid = await bcrypt.compare(password, result[0].password);
		if (! passwordValid)
			throw new Error('Unknown email or invalid password');
		if (result[0].account_locked)
			throw new Error('User account is locked');
		const userId = result[0].id;
		return userId;
	}

	static async generateAccessToken(userId) {
		const accessTokenDuration = '1m'; // TODO move this in configuration file
		const payload = {
			type: 'access',
			user_id: userId
		};
		return jwt.sign(payload, this.#secret, { expiresIn: accessTokenDuration });
	}

	static async generateRefreshToken(userId) {
		const db = this.#model.db;
		const refreshTokenDuration = 365; // TODO move this in configuration file
		const expirationDate = new Date (Date.now() + refreshTokenDuration * 86400000);
		const sqlRequest = 'INSERT INTO tokens(id_user, expires_at) VALUES (?, ?)';
		console.log("dOm sql:" + sqlRequest);
		console.log("dOm userId:" + userId);
		const sqlParams = [
			userId,
			expirationDate
		];
		const result = await db.query(sqlRequest, sqlParams);
		console.log("dOm ok");
		if (result.code)
			throw new Error(result.code);
		if (result.length === 0)
			throw new Error('Can not store refresh token');
		const tokenId = result.insertId;
		const payload = {
			type: 'refresh',
			user_id: userId,
			token_id: tokenId
		};
		return jwt.sign(payload, this.#secret, { expiresIn: `${refreshTokenDuration}days` });
	}

	static checkAccessToken(token) {
		return new Promise( (resolve, reject) => {
			jwt.verify(token, this.#secret, (err, decoded) => {
				if (err !== null)  {
					if (err.constructor.name === 'TokenExpiredError')
						reject('Expired token');
					else
						reject('Invalid token');
				}
				if (decoded.type !== 'access')
					reject('Not an access token');
				if (isNaN(decoded.user_id))
					reject(`Invalid token content`);
				resolve(decoded.user_id);
			});
		});
	}

	static async checkRefreshToken(token) {
		assert(this.#model !== null);
		const db = this.#model.db;
		const decodeToken = new Promise( (resolve, reject) => {
			jwt.verify(token, this.#secret, (err, decoded) => {
				if (err !== null)  {
					if (err.constructor.name === 'TokenExpiredError')
						reject('Expired token');
					else
						reject('Invalid token');
				}
				if (decoded.type !== 'refresh')
					reject('Not an refresh token');
				if (isNaN(decoded.token_id) || isNaN(decoded.user_id))
					reject(`Invalid token content`);
				resolve([decoded.token_id, decoded.user_id]);
			});
		});
		const [tokenId, userId] = await decodeToken;

		const sqlRequest = 'SELECT id FROM tokens WHERE id = ?';
		console.log("dOm sql:" + sqlRequest);
		const sqlParams = [ tokenId ];
		const result = await db.query(sqlRequest, sqlParams);
		if (result.code)
			throw new Error(result.code);
		const tokenFound = (result.length === 0) ? false : true
		
		return [tokenFound, tokenId, userId];
	}


	static async deleteRefreshToken(tokenId) {
		assert(this.#model !== null);
		const db = this.#model.db;
		const sqlRequest = 'DELETE FROM tokens WHERE id = ?';
		console.log("dOm sql:" + sqlRequest);
		const sqlParams = [ tokenId ];
		const result = await db.query(sqlRequest, sqlParams);
		return (result.affectedRows === 0) ? false : true;
	}


	static async checkAccountLocked(userId) {
		assert(this.#model !== null);
		const db = this.#model.db;
		const sqlRequest = 'SELECT account_locked FROM users WHERE id= ?';
		console.log("dOm sql:" + sqlRequest);
		const sqlParams = [ userId ];
		const result = await db.query(sqlRequest, sqlParams);
		if (result.code)
			throw new Error(result.code);
		if (result.length === 0) 
			throw new Error('User not found');
		const locked = result[0].account_locked;
		return locked;
	}

	static async lockAccount(userId) {
		assert(this.#model !== null);
		const db = this.#model.db;
		const sqlRequest = 'UPDATE users SET account_locked = ? WHERE id= ?';
		console.log("dOm sql:" + sqlRequest);
		const sqlParams = [ true, userId ];
		const result = await db.query(sqlRequest, sqlParams);
		if (result.code)
			throw new Error(result.code);
		if (result.affectedRows=== 0) 
			throw new Error('User not found');
	}


}

module.exports = (config) => {
	AuthModel.initialize(config);
	return AuthModel;
}

