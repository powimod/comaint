{% render "../../templates/license_header_js.liquid",
		project     : project.attributes.backend_project_name,
  		description : project.attributes.backend_project_description,
		authors     : project.attributes.authors,
		copyright   : project.attributes.copyright,
		filename    : 'auth-routes.js'
		%}
{% liquid 
	assign authObjectName = project.attributes.auth_object
	assign authTableName  = project.attributes.auth_table_name
	assign authIdentProp = project.attributes.auth_ident_property
	assign authPasswordProp = project.attributes.auth_password_property
%}
'use strict';
const assert = require('assert');

let _config = null;
let _authModel = null;

exports.initialize = (app, authModel, View, config) => {
	assert(config !== undefined);
	_config = config;
	_authModel = authModel;

	app.post('/api/{{project.attributes.api_version}}/auth/register', async (request, response) => {
		try {
			const {{authIdentProp}} = request.body.{{authIdentProp}};
			if ({{authIdentProp}} === undefined)
				throw new Error(`Can't find <{{authIdentProp}}> in request body`);
			const {{authPasswordProp}} = request.body.{{authPasswordProp}};
			if ({{authPasswordProp}} === undefined)
				throw new Error(`Can't find <{{authPasswordProp}}> in request body`);
			const result = await _authModel.register({{authIdentProp}}, {{authPasswordProp}});
			const {{authObjectName}}Id = result.{{authObjectName}}Id; 
			assert({{authObjectName}}Id !== undefined);
			const newAccessToken  = await _authModel.generateAccessToken({{authObjectName}}Id);
			const newRefreshToken = await _authModel.generateRefreshToken({{authObjectName}}Id);
			response.json({ ok : true, 
				'{{authObjectName}}-id': {{authObjectName}}Id,
				'access-token': newAccessToken,
				'refresh-token': newRefreshToken
			});
		}
		catch (error) {
			const errorMessage = (error.message !== undefined) ? error.message : error;
			console.error(errorMessage);
			response.json({ ok : false, error: errorMessage });
		}
	});

	app.post('/api/{{project.attributes.api_version}}/auth/login', async (request, response) => {
		try {
			const {{authIdentProp}} = request.body.{{authIdentProp}};
			if ({{authIdentProp}} === undefined)
				throw new Error(`Can't find <{{authIdentProp}}> in request body`);
			const {{authPasswordProp}} = request.body.{{authPasswordProp}};
			if ({{authPasswordProp}} === undefined)
				throw new Error(`Can't find <{{authPasswordProp}}> in request body`);

			const login = await _authModel.login({{authIdentProp}}, {{authPasswordProp}});
			const {{authObjectName}}Id = login.{{authObjectName}}Id;
			assert (! isNaN({{authObjectName}}Id)) ;
			const newAccessToken  = await _authModel.generateAccessToken({{authObjectName}}Id);
			const newRefreshToken = await _authModel.generateRefreshToken({{authObjectName}}Id);
			response.json({ ok : true, 
				'{{authObjectName}}-id' : {{authObjectName}}Id,
				'access-token': newAccessToken,
				'refresh-token': newRefreshToken
			});
		}
		catch (error) {
			const errorMessage = (error.message !== undefined) ? error.message : error;
			console.error(errorMessage);
			response.json({ ok : false, error: errorMessage });
		}
	});

	app.get('/api/{{project.attributes.api_version}}/auth/logout', async (request, response) => {
		try {
			throw new Error("Logout is not yet implemented");
		}
		catch (error) {
			const errorMessage = (error.message !== undefined) ? error.message : error;
			console.error(errorMessage);
			response.json({ ok : false, error: errorMessage });
		}
	});

	app.post('/api/{{project.attributes.api_version}}/auth/logout', async (request, response) => {
		try {
			const refreshToken = request.body.refreshToken;
			if (refreshToken === undefined)
				throw new Error(`Can't find <refreshToken> in request body`);
			await _authModel.logout(refreshToken);
			response.json({ ok : true});
		}
		catch (error) {
			const errorMessage = (error.message !== undefined) ? error.message : error;
			console.error(errorMessage);
			response.json({ ok : false, error: errorMessage });
		}
	});


	app.post('/api/{{project.attributes.api_version}}/auth/refresh', async (request, response) => {
		try {
			const refreshToken = request.body.token;
			if (refreshToken === undefined)
				throw new Error(`Can't find <token> in request body`);
			const [tokenFound, tokenId, {{authObjectName}}Id ] = await _authModel.checkRefreshToken(refreshToken);

			if (! tokenFound) {
				// if a token is not found, it should be an attempt to usurp cookie :
				// since a refresh token is deleted when used, it will not be found with a second attempt to use it.
				await _authModel.lockAccount({{authObjectName}}Id);
				throw new Error('Attempt to reuse a token');
			}

			await _authModel.deleteRefreshToken(tokenId);

			if (await _authModel.checkAccountLocked({{authObjectName}}Id))
				throw new Error('Account locked');

			const newAccessToken  = await _authModel.generateAccessToken({{authObjectName}}Id);
			const newRefreshToken = await _authModel.generateRefreshToken({{authObjectName}}Id);

			response.json({ ok : true, 
				'{{authObjectName}}-id' : {{authObjectName}}Id,
				'access-token': newAccessToken,
				'refresh-token': newRefreshToken
			});
		}
		catch (error) {
			const errorMessage = (error.message !== undefined) ? error.message : error;
			console.error(errorMessage);
			response.json({ ok : false, error: errorMessage });
		}
	});

}

exports.withAuth = async (request, response, next) => {
	assert(_authModel !== null);
	try {
		const token = request.headers['x-access-token'];
		if (token === undefined) 
			throw new Error(`HTTP header <x-access-token> not found`);
		const {{authObjectName}}Id = await _authModel.checkAccessToken(token);
		request.{{authObjectName}}Id = {{authObjectName}}Id;
		next();
	}
	catch (error) {
		const errorMessage = (error.message !== undefined) ? error.message : error;
		response.json({ ok: false, error: errorMessage });
	}
}

